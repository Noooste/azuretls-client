name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  # First: Run tests to ensure everything works
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-multilib

      - name: Run tests
        run: |
          # Test main library
          if [ -d "test" ]; then
            go test -v ./test
          else
            echo "No test directory found, running go test on all packages"
            go test -v ./...
          fi

      - name: Test CFFI build
        working-directory: cffi
        run: |
          # Verify CFFI can build
          if [ -f "Makefile" ]; then
            make
          else
            CGO_ENABLED=1 go build -buildmode=c-shared -o libazuretls.so main.go
          fi
          
          # Test examples if they exist
          if [ -d "examples" ] && [ -f "examples/Makefile" ]; then
            cd examples
            make
          fi
          
          echo "‚úÖ CFFI build test passed!"

  # Second: Generate changelog
  generate-changelog:
    needs: test
    runs-on: ubuntu-latest
    outputs:
      changelog: ${{ steps.changelog.outputs.changelog }}
      tag: ${{ steps.tag.outputs.tag }}
      previous_tag: ${{ steps.previous_tag.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get current tag
        id: tag
        run: echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Get previous tag
        id: previous_tag
        run: |
          PREVIOUS_TAG=$(git tag --sort=-version:refname | head -2 | tail -1)
          echo "tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          CURRENT_TAG="${{ steps.tag.outputs.tag }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.tag }}"
          
          chmod +x .github/scripts/generate-changelog.sh
          bash .github/scripts/generate-changelog.sh "$PREVIOUS_TAG" "$CURRENT_TAG" > changelog.txt
          
          # Set multiline output properly
          {
            echo 'changelog<<EOF'
            cat changelog.txt
            echo EOF
          } >> $GITHUB_OUTPUT

      - name: Upload changelog artifact
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: changelog.txt

  # Third: Build all platforms (only after tests pass)
  build-cffi:
    needs: [test, generate-changelog]
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds
          - os: ubuntu-latest
            goos: linux
            goarch: amd64
            name: linux-amd64
          - os: ubuntu-latest
            goos: linux
            goarch: arm64
            name: linux-arm64
          - os: ubuntu-latest
            goos: linux
            goarch: 386
            name: linux-386
          - os: ubuntu-latest
            goos: linux
            goarch: arm
            name: linux-arm

          # Windows builds
          - os: windows-latest
            goos: windows
            goarch: amd64
            name: windows-amd64
          - os: windows-latest
            goos: windows
            goarch: 386
            name: windows-386
          - os: windows-latest
            goos: windows
            goarch: arm64
            name: windows-arm64

          # macOS builds
          - os: macos-latest
            goos: darwin
            goarch: amd64
            name: darwin-amd64
          - os: macos-latest
            goos: darwin
            goarch: arm64
            name: darwin-arm64

          # FreeBSD builds
          - os: ubuntu-latest
            goos: freebsd
            goarch: amd64
            name: freebsd-amd64
          - os: ubuntu-latest
            goos: freebsd
            goarch: arm64
            name: freebsd-arm64

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Install dependencies (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-multilib gcc-aarch64-linux-gnu gcc-arm-linux-gnueabihf

      - name: Install dependencies (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          choco install tdm-gcc-64 -y

      - name: Install dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          xcode-select --install 2>/dev/null || true

      - name: Set CC for cross-compilation
        run: |
          if [ "${{ matrix.goos }}" = "linux" ] && [ "${{ matrix.goarch }}" = "arm64" ]; then
            echo "CC=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
          elif [ "${{ matrix.goos }}" = "linux" ] && [ "${{ matrix.goarch }}" = "arm" ]; then
            echo "CC=arm-linux-gnueabihf-gcc" >> $GITHUB_ENV
          fi
        shell: bash

      - name: Get version
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
        shell: bash

      - name: Build CFFI library
        working-directory: cffi
        run: |
          # Clean version string (remove 'v' prefix and any invalid characters)
          VERSION_CLEAN=$(echo "${{ steps.version.outputs.version }}" | sed 's/^v//' | sed 's/[^a-zA-Z0-9._-]/_/g')
          
          # Set library extension based on OS
          if [ "${{ matrix.goos }}" = "windows" ]; then
            EXT=".dll"
          elif [ "${{ matrix.goos }}" = "darwin" ]; then
            EXT=".dylib"
          else
            EXT=".so"
          fi
          
          # Build the library with clean naming: azuretls-1.2.3-linux-amd64.so
          LIB_NAME="azuretls-${VERSION_CLEAN}-${{ matrix.name }}${EXT}"
          CGO_ENABLED=1 GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }} \
          go build -buildmode=c-shared \
          -ldflags="-s -w -X 'main.Version=${{ steps.version.outputs.version }}'" \
          -o "$LIB_NAME" main.go
          
          # Verify the build was successful
          if [ ! -f "$LIB_NAME" ]; then
            echo "‚ùå Build failed: library not created"
            exit 1
          fi
          
          # Copy header file with same naming pattern
          if [ -f "azuretls.h" ]; then
            cp azuretls.h "azuretls-${VERSION_CLEAN}-${{ matrix.name }}.h"
          else
            echo "‚ö†Ô∏è Warning: azuretls.h not found"
          fi
          
          # Set environment variables for next steps
          echo "LIB_NAME=$LIB_NAME" >> $GITHUB_ENV
          echo "VERSION_CLEAN=$VERSION_CLEAN" >> $GITHUB_ENV
        shell: bash
        env:
          CGO_ENABLED: 1

      - name: Verify build
        working-directory: cffi
        run: |
          # Basic verification that the library was built
          if [ "${{ matrix.goos }}" = "windows" ]; then
            EXT=".dll"
          elif [ "${{ matrix.goos }}" = "darwin" ]; then
            EXT=".dylib"
          else
            EXT=".so"
          fi
          
          LIBRARY="libazuretls_${{ matrix.name }}${EXT}"
          
          if [ -f "$LIBRARY" ]; then
            echo "‚úÖ Library built successfully: $LIBRARY"
            ls -lh "$LIBRARY"
          
            # Check if it's a valid binary (basic check)
            file "$LIBRARY" || true
          else
            echo "‚ùå Library not found: $LIBRARY"
            exit 1
          fi
        shell: bash

      - name: Create archive
        working-directory: cffi
        run: |        
          # Copy header file to standard name for easier usage
          if [ -f "azuretls-${{ env.VERSION_CLEAN }}-${{ matrix.name }}.h" ]; then
            cp "azuretls-${{ env.VERSION_CLEAN }}-${{ matrix.name }}.h" "azuretls.h"
          fi
          
          # Create a simple info file
          cat > "azuretls-${{ env.VERSION_CLEAN }}-${{ matrix.name }}.txt" << 'EOF'
          AzureTLS HTTP Client Library
          Version: ${{ steps.version.outputs.version }}
          Platform: ${{ matrix.goos }}/${{ matrix.goarch }}
          Built: $(date -u)
          Library: ${{ env.LIB_NAME }}
          
          Usage:
          1. Download both the library file and azuretls.h
          2. Link against the library in your C/C++ project
          3. Include azuretls.h in your source code
          
          For examples and documentation, see: https://github.com/${{ github.repository }}
          EOF
          
          echo "‚úÖ Prepared library files for direct upload"
          ls -la azuretls-${{ env.VERSION_CLEAN }}-${{ matrix.name }}.*
        shell: bash

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: cffi-${{ matrix.name }}
          path: |
            cffi/${{ env.LIB_NAME }}
            cffi/azuretls.h
            cffi/azuretls-${{ env.VERSION_CLEAN }}-${{ matrix.name }}.txt

  # Fourth: Create release (only after all builds succeed)
  create-release:
    needs: [generate-changelog, build-cffi]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Get version
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          
          # Find and copy all library files directly (no archives)
          find artifacts -name "azuretls-*.so" -o -name "azuretls-*.dll" -o -name "azuretls-*.dylib" | while read file; do
            filename=$(basename "$file")
            echo "Preparing library: $filename"
            cp "$file" "release-assets/$filename"
          done
          
          # Copy one header file (they're all the same)
          find artifacts -name "azuretls.h" | head -1 | while read file; do
            if [ -f "$file" ]; then
              echo "Preparing header: azuretls.h"
              cp "$file" "release-assets/azuretls.h"
            fi
          done
          
          # Copy info files
          find artifacts -name "azuretls-*.txt" | while read file; do
            filename=$(basename "$file")
            echo "Preparing info: $filename"
            cp "$file" "release-assets/$filename"
          done
          
          echo "üì¶ Release assets prepared:"
          ls -la release-assets/
          
          # Verify we have library files
          LIB_COUNT=$(find release-assets -name "azuretls-*.*" | grep -E "\.(so|dll|dylib)$" | wc -l)
          echo "Total library files: $LIB_COUNT"
          
          if [ "$LIB_COUNT" -lt 10 ]; then
            echo "‚ö†Ô∏è Warning: Expected more library files, only found $LIB_COUNT"
          fi

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: Release ${{ steps.version.outputs.version }}
          body: ${{ needs.generate-changelog.outputs.changelog }}
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, '-') }}
          files: release-assets/*
          token: ${{ secrets.GITHUB_TOKEN }}
          fail_on_unmatched_files: true

      - name: Release Summary
        run: |
          echo "üéâ Release created successfully!"
          echo "Tag: ${{ steps.version.outputs.version }}"
          echo "Library files uploaded: $(find release-assets -name "azuretls-*.*" | grep -E "\.(so|dll|dylib)$" | wc -l)"
          echo "Release URL: ${{ steps.create_release.outputs.url }}"